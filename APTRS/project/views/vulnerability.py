import logging

from django.core.exceptions import ObjectDoesNotExist
from django.db.models.signals import post_save
from django.shortcuts import render, get_object_or_404
from rest_framework import status
from rest_framework.decorators import (api_view, parser_classes,
                                       permission_classes)
from rest_framework.parsers import FormParser, MultiPartParser
from rest_framework.permissions import IsAuthenticated, IsAdminUser
from rest_framework.response import Response
from utils.filters import (VulnerableinstanceFilter,
                           paginate_queryset)
from utils.permissions import custom_permission_required

from ..models import (Project, Vulnerability,
                     Vulnerableinstance)
from ..nessus import is_valid_csv
from ..serializers import (Instanceserializers,
                          Vulnerabilityserializers)

logger = logging.getLogger(__name__)



@api_view(['POST'])
@permission_classes([IsAuthenticated,IsAdminUser])
@custom_permission_required(['Manage Projects'])
@parser_classes([MultiPartParser,FormParser])
def Nessus_CSV(request, pk):
    try:
        Project.objects.get(pk=pk)
    except ObjectDoesNotExist:
        logger.error("Project Not Found, Project: %s is incorrect", pk)
        return Response({"message": "Project not found"}, status=status.HTTP_404_NOT_FOUND)
    file = request.FILES['file']
    output = is_valid_csv(file,pk)

    if not output:
        return Response({'status': 'Failed',"message": "Invalid CSV, Unable to parse or missing required fields"})

    else:
        allvuln = Vulnerability.objects.filter(project=pk)
        serializer = Vulnerabilityserializers(allvuln, many=True)
        return Response(serializer.data)


@api_view(['POST'])
@permission_classes([IsAuthenticated,IsAdminUser])
@custom_permission_required(['Manage Projects'])
def create_vulnerability(request):
    projectid = request.data.get('project')

    try:
        Projectobject = Project.objects.get(pk=projectid)
    except ObjectDoesNotExist:
        logger.error("Project Not Found, Project: %s is incorrect", projectid)
        return Response({"message": "Project not found"}, status=status.HTTP_404_NOT_FOUND)

    vulnserializer = Vulnerabilityserializers(data=request.data,context = {"request": request})
    if vulnserializer.is_valid(raise_exception=True):
        instacesserilization = Instanceserializers(data=request.data.get('instance'), many=True)
        if instacesserilization.is_valid():
            vulnerability = vulnserializer.save()
            instacesserilization.save(vulnerabilityid=vulnerability, project=Projectobject)
            respdata = vulnserializer.data
            respdata.update({'instance': instacesserilization.data})
            return Response(respdata, status=201)
        else:
            logger.error("instances are incorrect")
            return Response(vulnserializer.errors, status=400)
    else:
        logger.error(vulnserializer.errors)
        return Response(vulnserializer.errors, status=400)



@api_view(['GET'])
@permission_classes([IsAuthenticated,IsAdminUser])
def projectfindingview(request, pk):
    try:
        vulnerability = Vulnerability.objects.filter(project=pk)
        serializer = Vulnerabilityserializers(vulnerability, many=True,context={'exclude_instances': True})
        return Response(serializer.data)
    except ObjectDoesNotExist:
        logger.error("Project Vulnerrability not found for id=%s", pk)
        return Response({"message": "Vulnerrability not found"}, status=status.HTTP_404_NOT_FOUND)




@api_view(['POST'])
@permission_classes([IsAuthenticated,IsAdminUser])
@custom_permission_required(['Manage Projects'])
def projectvulnedit(request,pk):
    vulnerability = Vulnerability.objects.get(pk=pk)
    serializer = Vulnerabilityserializers(instance=vulnerability,data=request.data,context={'request': request})
    if serializer.is_valid(raise_exception=True):
        serializer.save()
        respdata={'Status':"Success"}
        respdata.update(serializer.data)
        return Response(respdata)
    else:
        logger.error("Serializer errors: %s", str(serializer.errors))
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)





@api_view(['DELETE'])
@permission_classes([IsAuthenticated,IsAdminUser])
@custom_permission_required(['Manage Projects'])
def projectvulndelete(request):
    vuln = Vulnerability.objects.filter(id__in=request.data)
    vuln.delete()
    respdata={'Status':"Success"}
    return Response(respdata)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
@custom_permission_required(['View Specific Vulnerability'])
def projectvulnview(request,pk):
    try:
        vulnerability = Vulnerability.objects.get(pk=pk)
        serializer = Vulnerabilityserializers(vulnerability,many=False)
        instances = Vulnerableinstance.objects.filter(vulnerabilityid=pk)
        instancesserializer = Instanceserializers(instances,many=True)
        serialized_data = serializer.data
        serialized_data['instance'] = instancesserializer.data
        return Response(serialized_data)
        #return Response(serializer.data)
    except ObjectDoesNotExist:
        logger.error("Vulnerrability not found for id=%s", pk)
        return Response({"message": "Vulnerrability not found"}, status=status.HTTP_404_NOT_FOUND)




@api_view(['GET'])
@permission_classes([IsAuthenticated,IsAdminUser])
def projectvulninstances_filter(request,pk):
    sort_order = request.GET.get('order_by', 'desc')
    sort_field = request.GET.get('sort', 'id') or 'id'
    instancedetails = Vulnerableinstance.objects.filter(vulnerabilityid=pk)

    instance_filter = VulnerableinstanceFilter(request.GET, queryset=instancedetails)
    filtered_queryset = instance_filter.qs
    if sort_order == 'asc':
        filtered_queryset = filtered_queryset.order_by(sort_field)
    else:
        filtered_queryset = filtered_queryset.order_by('-'+sort_field)
    #filtered_queryset = instance_filter.qs
    paginator, paginated_queryset = paginate_queryset(filtered_queryset, request)
    serializer = Instanceserializers(paginated_queryset, many=True)

    return paginator.get_paginated_response(serializer.data)




@api_view(['GET'])
@permission_classes([IsAuthenticated,IsAdminUser])
def projectvulninstances(request,pk):
    instances = Vulnerableinstance.objects.filter(vulnerabilityid=pk)
    if not instances:
        logger.error("Vulnerrability Instance not found for id=%s", pk)
        return Response({"message": "Instancce not found"}, status=status.HTTP_404_NOT_FOUND)
    else:
        serializer = Instanceserializers(instances,many=True)
        return Response(serializer.data)



@api_view(['POST'])
@permission_classes([IsAuthenticated,IsAdminUser])
@custom_permission_required(['Manage Projects'])
def projectaddinstances(request,pk):
    try:
        vulnerability = Vulnerability.objects.get(pk=pk)
        project = vulnerability.project
        #request.data['vulnerabilityid'] = pk
        serializer = Instanceserializers(data=request.data,many=True)
        if serializer.is_valid(raise_exception=True):
            serializer.save(vulnerabilityid=vulnerability,project=project)
            return Response(serializer.data)
        else:
            logger.error("Serializer errors: %s", str(serializer.errors))
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    except ObjectDoesNotExist:
        logger.error("Vulnerrability not found for id=%s", pk)
        return Response({"message": "Vulnerrability not found"}, status=status.HTTP_404_NOT_FOUND)




@api_view(['POST'])
@permission_classes([IsAuthenticated,IsAdminUser])
@custom_permission_required(['Manage Projects'])
def projecteditinstances(request,pk):
    try:
        instance = Vulnerableinstance.objects.get(pk=pk)

        serializer = Instanceserializers(instance=instance,data=request.data,partial=True)
        if serializer.is_valid(raise_exception=True):
            serializer.save()
            return Response(serializer.data)
        else:
            logger.error("Serializer errors: %s", str(serializer.errors))
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    except ObjectDoesNotExist:
        logger.error("Instance not found for id=%s", pk)
        return Response({"message": "Instance not found"}, status=status.HTTP_404_NOT_FOUND)





@api_view(['DELETE'])
@permission_classes([IsAuthenticated,IsAdminUser])
@custom_permission_required(['Manage Projects'])
def projectdeleteinstances(request):
    vluninstace = Vulnerableinstance.objects.filter(id__in=request.data)
    if not vluninstace:
        logger.error("Instance not found")
        return Response({"message": "Instance not found"}, status=status.HTTP_404_NOT_FOUND)
    else:
        vluninstace.delete()
        respdata={'Status':"Success"}
        return Response(respdata)


@api_view(['POST'])
@permission_classes([IsAuthenticated,IsAdminUser])
@custom_permission_required(['Manage Projects'])
def projectinstancesstatus(request):
    vluninstace = Vulnerableinstance.objects.filter(id__in=request.data)
    if not vluninstace:
        logger.error("Instance not found")
        return Response({"message": "Instance not found"}, status=status.HTTP_404_NOT_FOUND)
    else:
        instancestatus = request.query_params.get('status')
        if instancestatus is None:
            logger.error("Status not defined")
            return Response({"message": "Missing 'status' parameter"}, status=status.HTTP_400_BAD_REQUEST)

        choices = dict(Vulnerableinstance.status.field.choices)
        if instancestatus not in choices:
            logger.error("Instance Status is not valid from %s", choices)
            return Response({"message": "Invalid status choice"}, status=status.HTTP_400_BAD_REQUEST)
        vluninstace.update(status=instancestatus)
        respdata = {'status': 'Success'}
        vulnerability_ids = vluninstace.values_list('vulnerabilityid', flat=True).distinct()
        for vulnerability_id in vulnerability_ids:
            vulnobject = Vulnerability.objects.get(id=vulnerability_id)
            post_save.send(sender=Vulnerability, instance=vulnobject, created=False)

        return Response(respdata)



@api_view(['GET'])
@permission_classes([IsAuthenticated,IsAdminUser])
@custom_permission_required(['Manage Projects'])
def projectvulnerabilitystatus(request,pk):
    try:
        vuln = Vulnerability.objects.get(pk=pk)
    except ObjectDoesNotExist:
        logger.error("Vulnerability not found for id=%s", pk)
        return Response({"Vulnerability": "Retest not found"}, status=status.HTTP_404_NOT_FOUND)

    instancestatus = request.query_params.get('status')
    if instancestatus is None:
        logger.error("Status not defined")
        return Response({"message": "Missing 'status' parameter"}, status=status.HTTP_400_BAD_REQUEST)

    choices = dict(Vulnerability.status.field.choices)
    if instancestatus not in choices:
        logger.error("Instance Status is not valid from %s", choices)
        return Response({"message": "Invalid status choice"}, status=status.HTTP_400_BAD_REQUEST)

    vluninstace = Vulnerableinstance.objects.filter(vulnerabilityid=pk)
    vluninstace.update(status=instancestatus)
    vuln.status = instancestatus
    vuln.save()
    respdata = {'status': 'Success'}
    return Response(respdata)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def vulnerability_view(request, pk):
    vulnerability = get_object_or_404(Vulnerability, pk=pk)
    instances = Vulnerableinstance.objects.filter(vulnerabilityid=pk)
    return render(request, 'vulnerabilities.html', {'vuln': [vulnerability], 'instances': instances})